#include <string.h>
#include <stdbool.h>
#include <stdlib.h>
#include "FreeRTOS.h"
#include "task.h"
#include "debug.h"
#include "uartRXTask.h"
#include "fetControl.h"

#define INPUT_BUFFER_SIZE (100)

#define CELL_TEST_LOGGING_START_DELAY_MS 500
#define CELL_TEST_LOG_TIME_MS 6500
#define CELL_TEST_LOGGING_END_DELAY_MS 2500

#define CELL_TEST_LOG_DELAY_FROM_START_MS CELL_TEST_LOGGING_START_DELAY_MS
#define CELL_TEST_END_OF_CELL_TEST_FROM_START_MS (CELL_TEST_LOG_DELAY_FROM_START_MS + CELL_TEST_LOG_TIME_MS)
#define CELL_TEST_END_OF_LOGGING_TIME_FROM_START_MS (CELL_TEST_END_OF_CELL_TEST_FROM_START_MS + CELL_TEST_LOGGING_END_DELAY_MS)

static char rxString[INPUT_BUFFER_SIZE];
uint32_t rxIndex = 0;
static float currentTarget = 0.0f;

static TickType_t startCellTestTimeMs = 0;
static TickType_t abortCellTestTimeMs = 0; // A stop request was made to abort the cell test if non zero

static void processInput(char* inputString);

void uartRXTask(void const* argument) {
    while (1) {
        char rxBuffer;
        if (xQueueReceive(uartRxQueue, &rxBuffer, portMAX_DELAY) != pdTRUE) {
            ERROR_PRINT("Error Receiving from UART Rx Queue\n");
            handleError();
        }

        if (rxBuffer == '\n') {
            /* A newline character was received, so the input command string is
            complete and can be processed. */
            processInput(rxString);

            /* All the strings generated by the input command have been sent.
            Processing of the command is complete.  Clear the input string ready
            to receive the next command. */
            rxIndex = 0;
            memset(rxString, 0x00, INPUT_BUFFER_SIZE);
        } else {
            /* The if() clause performs the processing after a newline character
            is received.  This else clause performs the processing if any other
            character is received. */

            if (rxBuffer == '\r') {
                /* Ignore carriage returns. */
            } else if (rxBuffer == '\b') {
                /* Backspace was pressed.  Erase the last character in the input
                buffer - if there are any. */
                if (rxIndex > 0) {
                    rxIndex--;
                    rxString[rxIndex] = '\0';
                }
            } else {
                /* A character was entered.  It was not a new line, backspace
                or carriage return, so it is accepted as part of the input and
                placed into the input buffer.  When a \n is entered the complete
                string will be passed to the command interpreter. */
                if (rxIndex < INPUT_BUFFER_SIZE) {
                    rxString[rxIndex] = rxBuffer;
                    rxIndex++;
                } else {
                    ERROR_PRINT("Rx string buffer overflow\n");
                }
            }
        }
    }
}



void processInput(char* inputString) {
    bool isNumber = true;
    bool processedPeriod = false; // Only allow one period for a numerical input
    char* c = inputString;
    while (*c != '\0')
    {
        DEBUG_PRINT("%c\r\n", *c);
        // Check to see if its a number
        if (*c < '0' || *c > '9')
        {
            // There can only be one period per decimal
            if (!processedPeriod && *c == '.')
            {
                processedPeriod = true;
            }
            else
            {
                isNumber = false;
                break;
            }
        }
        ++c;
    }

    if (isNumber)
    {
        currentTarget = (float)atof(inputString);
        resetFetDutyCycle();
    }
    else if (startCellTestTimeMs == 0 && strcmp(inputString, "start") == 0)
    {
        // This tells the GUI to start logging
        DEBUG_PRINT("start\r\n");

        // Can't start a cellTest if one is in progress
        startCellTestTimeMs = xTaskGetTickCount();
    }
    else if (startCellTestTimeMs != 0 && strcmp(inputString, "stop") == 0)
    {
        abortCellTest();
    }
    else
    {
        DEBUG_PRINT("Unknown command\r\n");
    }
}

CellTestStatus_E getCellTestStatus(void)
{
    const TickType_t timeSinceCellTestRequest = pdMS_TO_TICKS(xTaskGetTickCount() - startCellTestTimeMs);
    if (abortCellTestTimeMs != 0U)
    {
        TickType_t timeSinceCellTestAbort = pdMS_TO_TICKS(xTaskGetTickCount() - abortCellTestTimeMs);
        if (timeSinceCellTestAbort < CELL_TEST_LOG_DELAY_FROM_START_MS)
        {
            return CellTestStatus_LOGGING;
        }
        else
        {
            // Tells the GUI to stop logging
            DEBUG_PRINT("stop\r\n");

            startCellTestTimeMs = 0U;
            abortCellTestTimeMs = 0U;
            return CellTestStatus_IDLE;
        }
    }
    else if (startCellTestTimeMs == 0)
    {
        return CellTestStatus_IDLE;
    }
    else if (timeSinceCellTestRequest < CELL_TEST_LOG_DELAY_FROM_START_MS)
    {
        return CellTestStatus_REQUESTED;
    }
    else if (timeSinceCellTestRequest < CELL_TEST_END_OF_CELL_TEST_FROM_START_MS)
    {
        return CellTestStatus_RUNNING;
    }
    else if (timeSinceCellTestRequest < CELL_TEST_END_OF_LOGGING_TIME_FROM_START_MS)
    {
        return CellTestStatus_LOGGING;
    }
    else
    {
        // Cell test done, reset state
        startCellTestTimeMs = 0U;

        // Tells the GUI to stop logging
        DEBUG_PRINT("stop\r\n");

        return CellTestStatus_IDLE;
    }
}

void abortCellTest(void)
{
    abortCellTestTimeMs = xTaskGetTickCount();
}

void setCurrentTarget(float newCurrentTarget)
{
    currentTarget = newCurrentTarget;
}

float getCurrentTarget(void)
{
    return currentTarget;
}
